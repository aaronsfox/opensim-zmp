#ifndef OPENSIM_ZMPFORCE_H_
#define OPENSIM_ZMPFORCE_H_
/* -------------------------------------------------------------------------- *
 *                   OpenSim: ZmpForce.h                                      *
 * -------------------------------------------------------------------------- *
 * Copyright (c) 2024 Stanford University and the Authors                     *
 *                                                                            *
 * Author(s): Antoine Falisse, Gil Serrancoli                                 *
 * Contributors: Peter Eastman                                                *
 *                                                                            *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may    *
 * not use this file except in compliance with the License. You may obtain a  *
 * copy of the License at http://www.apache.org/licenses/LICENSE-2.0          *
 *                                                                            *
 * Unless required by applicable law or agreed to in writing, software        *
 * distributed under the License is distributed on an "AS IS" BASIS,          *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   *
 * See the License for the specific language governing permissions and        *
 * limitations under the License.                                             *
 * -------------------------------------------------------------------------- */

#include "ZmpGroundReactions.h"

#include <OpenSim/Simulation/Model/Force.h>
#include <OpenSim/Common/Set.h>

// TODO: the contact half space force may be too complex for this force
// Consider a simpler example that takes recorded values and applies?

namespace OpenSim {
//=============================================================================
//=============================================================================
/**
 * TODO: add instructional content for ZmpForce
 *
 * @authors Aaron Fox
 * @version 1.0
 */
class OSIMZMP_API ZmpForce : public Force {
    OpenSim_DECLARE_CONCRETE_OBJECT(ZmpForce, Force);

public:

    //=========================================================================
    // PROPERTIES
    //=========================================================================

    OpenSim_DECLARE_PROPERTY(zero_moment_point_contact_body_name, std::string,
            "The name of the contact body in the ZeroMomentPointGroundReactions "
            "to which this particular force component connects to. Note that this "
            "IS NOT the body name, but rather the name of the associated "
            "ZeroMomentPointContactBody object.");

    OpenSim_DECLARE_PROPERTY(applied_to_body, std::string,
            "The name of the body to which the force is applied to.");

    /*OpenSim_DECLARE_PROPERTY(force_visualization_radius, double,
            "The radius of the cylinder that visualizes contact "
            "forces generated by this force component. Default: 0.01 m");

    OpenSim_DECLARE_OPTIONAL_PROPERTY(force_visualization_scale_factor, double,
            "(Optional) The scale factor that determines the length of the "
            "cylinder that visualizes contact forces generated by this force "
            "component. The cylinder will be one meter long when the contact "
            "force magnitude is equal to this value. If this property is not "
            "specified, the total weight of the model is used "
            "as the scale factor.")*/

    //=========================================================================
    // SOCKETS
    //=========================================================================

    OpenSim_DECLARE_SOCKET(zmp_ground_reactions, ZeroMomentPointGroundReactions,
            "The ZeroMomentPointGroundReactions component the force is connected to.");

    //=========================================================================
    // OUTPUTS
    //=========================================================================

    /*OpenSim_DECLARE_OUTPUT(contact_body_force, SimTK::Vector, getContactBodyForce,
            SimTK::Stage::Dynamics);*/

    //// The force applied to the contact body
    //OpenSim_DECLARE_OUTPUT(force_applied, SimTK::Vec3, getForceApplied,
    //    SimTK::Stage::Dynamics);

    //// The torque applied to the contact body
    //OpenSim_DECLARE_OUTPUT(torque_applied, SimTK::Vec3, getTorqueApplied,
    //        SimTK::Stage::Dynamics);

    //// The force applied to the contact body
    //OpenSim_DECLARE_OUTPUT(point_of_application, SimTK::Vec3, getApplicationPoint,
    //        SimTK::Stage::Dynamics);

    //=========================================================================
    // CONTRUCTORS
    //=========================================================================

    /** Default constructor */
    ZmpForce();

    /** Constructor with object name and ZMP Ground Reactions socket */ 
    ZmpForce(const std::string& name,
            const ZeroMomentPointGroundReactions& zmpGroundReactions);

    /** Constructor with object name, ZMP Ground Reactions socket and contact
    body name */ 
    ZmpForce(const std::string& name,
            const ZeroMomentPointGroundReactions& zmpGroundReactions,
            const std::string zeroMomentPointContactBodyName);

    /** Constructor with object name, ZMP Ground Reactions socket, contact
    body name and applied to body name */
    ZmpForce(const std::string& name,
            const ZeroMomentPointGroundReactions& zmpGroundReactions,
            const std::string zeroMomentPointContactBodyName,
            const std::string appliedToBodyName);

    //-----------------------------------------------------------------------------
    // SET and GET parameters
    //-----------------------------------------------------------------------------

    /** Set contact body name */
    void setZeroMomentPointContactBodyName(const std::string& contactBodyName) {
        set_zero_moment_point_contact_body_name(contactBodyName);
    }

    /** Get contact body name */
    const std::string& getZeroMomentPointContactBodyName() const {
        return get_zero_moment_point_contact_body_name();
    }

    /** Set applied to body name */
    void setAppliedToBody(const std::string& bodyName) {
        set_applied_to_body(bodyName);
    }

    /** Get applied to body name */
    const std::string& getAppliedToBody() const {
        return get_applied_to_body();
    }

    /** Set ZMP ground reactions connector */
    void setZeroMomentPointGroundReactions(const ZeroMomentPointGroundReactions& zmpGroundReactions) {
        connectSocket_zmp_ground_reactions(zmpGroundReactions);
    }

    /** Get ZMP ground reactions connector */
    const ZeroMomentPointGroundReactions&
        getZeroMomentPointGroundReactions() const {
        return getConnectee<ZeroMomentPointGroundReactions>(
                "zmpGroundReactions");
    }

    /** Get the computed force magnitude
    Note that computeForce must be evaluated first and this is done 
    automatically if the system is realised to dynamics. */
    /*const double& getForceMagnitude(const SimTK::State& state);*/

    //=========================================================================
    // COMPUTATION
    //=========================================================================

    /** Compute the ZMP ground reactions and apply it to the model */
    void computeForce(const SimTK::State& state,
            SimTK::Vector_<SimTK::SpatialVec>& bodyForces,
            SimTK::Vector& generalizedForces) const override;

    /** Get the ZMP ground reactions for the component */
    SimTK::Vector ZmpForce::getGroundReactions(
            const SimTK::State& state, const SimTK::Vector& udot) const;


    //=========================================================================
    // REPORTING
    //=========================================================================
    
    /** Obtain names of the quantities (column labels) of the force values to
    be reported. The order is the three forces (XYZ), three points (XYZ)
    and three torques (XYZ) applied on the contact body. Forces, points
    and torques are expressed in the ground frame. */
    Array<std::string> getRecordLabels() const override;

    /** Obtain the values to be reported that correspond to the labels. The
    values are expressed in the ground frame. */
    Array<double> getRecordValues(
        const SimTK::State& state) const override;

    /** Get a SimTK::Vector containing the forces, points and torques applied
    to the listed body. */
    /*SimTK::Vector getContactBodyForce(const SimTK::State& s) const;*/

protected:

    /** Create a SimTK::Force which implements this Force. */
    void extendConnectToModel(Model& model) override;
    void extendAddToSystem(SimTK::MultibodySystem& system) const override;
    /*void extendRealizeInstance(const SimTK::State& state) const override;*/
    /*void generateDecorations(bool fixed, const ModelDisplayHints& hints,
            const SimTK::State& state,
            SimTK::Array_<SimTK::DecorativeGeometry>& geometry) const override;*/

private:

    // INITIALIZATION

    // TODO: which of these are needed? (e.g. calcBodyForces probably needs to change...)

    void setNull();
    void constructProperties();
    /*mutable double m_forceVizScaleFactor;*/

    /*void calcBodyForces(const SimTK::State& s,
                        SimTK::Vector& bodyForces) const;*/

//==============================================================================
// DATA
//==============================================================================

    /** Pointer to the body that force is applied to */
    SimTK::ReferencePtr<const PhysicalFrame> _appliedToBody;

//=============================================================================
}; // END of class ZmpForce
//=============================================================================
//=============================================================================

} // namespace OpenSim

#endif // OPENSIM_ZMPFORCE_H_
